include "ffi.pixi";//functions, variables, constants

//constants
//constants
//constants

undefined = 0;
null = -1;
false = 0;
true = 1;
medium_array = 64;

//keycodes
//keycodes
//keycodes

KEY_NULL = 0;
KEY_SOH = 1;
KEY_STX = 2;
KEY_ETX = 3;
KEY_EOT = 4;
KEY_ENQ = 5;
KEY_ACK = 6;
KEY_BEL = 7;
KEY_BS = 8;
KEY_HT = 9;
KEY_LF = 10;
KEY_VT = 11;
KEY_FF = 12;
KEY_CR = 13;
KEY_SO = 14;
KEY_SI = 15;
KEY_DLE = 16;
KEY_DC1 = 17;
KEY_DC2 = 18;
KEY_DC3 = 19;
KEY_DC4 = 20;
KEY_NAK = 21;
KEY_SYN = 22;
KEY_ETB = 23;
KEY_CAN = 24;
KEY_EM = 25;
KEY_SUB = 26;
KEY_ESC = 27;
KEY_FS = 28;
KEY_GS = 29;
KEY_RS = 30;
KEY_US = 31;
//KEY_SPACE = 32;
KEY_EXCLAMATION_MARK = 33;
KEY_QUOTATION_MARK = 34;
KEY_HASH = 35;
KEY_DOLLAR = 36;
KEY_PERCENT = 37;
KEY_AMPERSAND = 38;
KEY_APOSTROPHE = 39;
KEY_LEFT_PARENTHESIS = 40;
KEY_RIGHT_PARENTHESIS = 41;
KEY_ASTERISK = 42;
KEY_PLUS = 43;
KEY_COMMA = 44;
KEY_MINUS = 45;
KEY_PERIOD = 46;
KEY_SLASH = 47;
KEY_0 = 48;
KEY_1 = 49;
KEY_2 = 50;
KEY_3 = 51;
KEY_4 = 52;
KEY_5 = 53;
KEY_6 = 54;
KEY_7 = 55;
KEY_8 = 56;
KEY_9 = 57;
KEY_COLON = 58;
KEY_SEMICOLON = 59;
KEY_LESS_THAN = 60;
KEY_EQUALS = 61;
KEY_GREATER_THAN = 62;
KEY_QUESTION_MARK = 63;
KEY_AT = 64;
KEY_A = 65;
KEY_B = 66;
KEY_C = 67;
KEY_D = 68;
KEY_E = 69;
KEY_F = 70;
KEY_G = 71;
KEY_H = 72;
KEY_I = 73;
KEY_J = 74;
KEY_K = 75;
KEY_L = 76;
KEY_M = 77;
KEY_N = 78;
KEY_O = 79;
KEY_P = 80;
KEY_Q = 81;
KEY_R = 82;
KEY_S = 83;
KEY_T = 84;
KEY_U = 85;
KEY_V = 86;
KEY_W = 87;
KEY_X = 88;
KEY_Y = 89;
KEY_Z = 90;
KEY_LEFT_BRACKET = 91;
KEY_BACKSLASH = 92;
KEY_RIGHT_BRACKET = 93;
KEY_CARET = 94;
KEY_UNDERSCORE = 95;
KEY_GRAVE_ACCENT = 96;
KEY_a = 97;
KEY_b = 98;
KEY_c = 99;
KEY_d = 100;
KEY_e = 101;
KEY_f = 102;
KEY_g = 103;
KEY_h = 104;
KEY_i = 105;
KEY_j = 106;
KEY_k = 107;
KEY_l = 108;
KEY_m = 109;
KEY_n = 110;
KEY_o = 111;
KEY_p = 112;
KEY_q = 113;
KEY_r = 114;
KEY_s = 115;
KEY_t = 116;
KEY_u = 117;
KEY_v = 118;
KEY_w = 119;
KEY_x = 120;
KEY_y = 121;
KEY_z = 122;
KEY_LEFT_BRACE = 123;
KEY_PIPE = 124;
KEY_RIGHT_BRACE = 125;
KEY_TILDE = 126;
//KEY_DELETE = 127;

//primitive functions
//primitive functions
//primitive functions

fn dummy()
{
    ret(0);
}

//memory functions
//memory functions
//memory functions

//container counter
container_counter = 0;

fn print_all()
{
    for($i = 0; $i < 512; $i+1)
    {
        printf("$%d=%s\n", $i, $i);
    }
    printf("\n");
}

fn container_count()
{
    $count = new();
    ret($count);
}
functions.container_count = container_count;

fn print_container_count()
{
    container_counter = container_count();
    printf("Container count: %d\n", container_counter);
    remove(container_counter);
}
functions.print_container_count = print_container_count;

fn log_container_count()
{
    container_counter = container_count();
    logf("Container count: %d\n", container_counter);
    remove(container_counter);
}
functions.log_container_count = log_container_count;

fn flex($object,$size)
{
    $newsize = get_size($object) + $size;
    resize($object,$newsize);
    ret($newsize);
}
functions.flex = flex;

//util functions
//util functions
//util functions

fn refresh_seed()
{
    rand_seed( get_timer() + get_ticks() );
}
functions.refresh_seed = refresh_seed;

fn random($min,$max)
{
    //considering that rand() returns a value between 0 and 32767
    ret((rand() % ($max - $min + 1)) + $min);
}
functions.random = random;

fn recursive_prop($obj, $prop)
{
    if(strstr($prop, ".") > -1)
    {
        $cloned = clone($prop);
        $splited = string_split($cloned, ".");
        $size = get_size($splited);
        for($i=0; $i < $size; $i+1)
        {
            if($splited[$i][0] > 47 && $splited[$i][0] < 58)
            {
                $obj = $obj[str_to_num($splited[$i])];
            }
            else
            {
                $obj = get_prop($obj, $splited[$i]);
            }
            remove($splited[$i]);
        }
        remove($splited);
        remove($cloned);
        ret($obj);
    }
    else
    {
        ret(get_prop($obj, $prop));
    }
}
functions.recursive_prop = recursive_prop;

fn recursive_set_prop($obj, $prop, $value)
{
    //printf("recursive_prop(%s,%s)\n", $obj, $prop);
    if(strstr($prop, ".") > -1)
    {
        $cloned = clone($prop);
        $splited = string_split($cloned, ".");
        $size = get_size($splited);
        for($i=0; $i < $size-1; $i+1)
        {
            if($splited[$i][0] > 47 && $splited[$i][0] < 58)
            {
                $obj = $obj[str_to_num($splited[$i])];
            }
            else
            {
                $obj = get_prop($obj, $splited[$i]);
            }
            remove($splited[$i]);
        }
        set_prop($obj, $splited[$size-1], $value);
        remove($splited[$size-1]);
        remove($splited);
        remove($cloned);
    }
    else
    {
        set_prop($obj, $prop, $value);
    }
}
functions.recursive_set_prop = recursive_set_prop;

fn default($obj, $default)
{
    if($obj == 0)
    {
        ret($default);
    }
    else
    {
        ret($obj);
    }
}
functions.default = default;

fn define ($name, $value)
{
    $target = recursive_prop(variables, $name);
    $target = $value;
}

fn create($name, $value)
{
    set_prop(variables, $name, $value);
}
functions.create = create;

fn create_empty($name)
{
    set_prop(variables, $name, new());
}
functions.create_empty = create_empty;

fn create_array($name, $size)
{
    set_prop(variables, $name, new($size));
}
functions.create_array = create_array;

fn create_matrix($name, $xsize, $ysize)
{
    set_prop(variables, $name, new($xsize, $ysize));
}
functions.create_matrix = create_matrix;

//list functions
//list functions
//list functions

fn list_push($list,$element)
{
    $list[flex($list, 1)-1] = $element;
}
functions.list_push = list_push;

fn list_pop($list)
{
    flex($list, -1);
}
functions.list_pop = list_pop;

fn list_insert($list,$element,$position)
{
    $oldsize = flex($list, 1) - 1;
    $position = default($position,$oldsize);
    for($i = $oldsize; $i >= $position; $i-1)
    {
        $list[$i+1] = $list[$i];
    }
    $list[$position] = $element;
    remove($oldsize);
}
functions.list_insert = list_insert;

fn list_remove($list,$position)
{
    $oldsize = get_size($list);
    for($i = $position; $i < $oldsize; $i+1)
    {
        $list[$i] = $list[$i+1];
    }
    resize($list,$oldsize - 1);
    remove($oldsize);
}
functions.list_remove = list_remove;

fn list_find($list,$element)
{
    $oldsize = get_size($list);
    for($i = 0; $i < $oldsize; $i+1)
    {
        if($list[$i] == $element)
        {
            ret($i);
        }
    }
    remove($oldsize);
    ret(-1);
}
functions.list_find = list_find;

//strings functions
//strings functions
//strings functions

fn string_new($size)
{
    $temp = "";
    $temp = new($size);
    ret($temp);
}
functions.string_new = string_new;

fn string_sub($string,$start,$end)
{
    $newstr = "";
    resize($newstr,$end - $start);
    $offset = 0;
    for($i = $start; $i < $end; $i+1)
    {
        $newstr[$offset] = $string[$i];
        $offset = $offset + 1;
    }
    ret($newstr);
}
functions.string_sub = string_sub;

//counting ocurrences using strstr
fn string_ocurrences($str1,$str2)
{
    $count = 0;
    $offset = 0;
    $len = strlen($str2);
    while($offset <= strlen($str1))
    {
        $offset = strstr($str1,$offset,$str2);
		if($offset == -1)
        {
            break;
        }
		$count = $count + 1;
        $offset = $offset + $len;
	}
    //remove($offset);
    ret($count);
}
functions.string_ocurrences = string_ocurrences;

//this string returns the positions of each ocurrence
fn string_ocurrences_advanced($str1,$str2)
{
    $count = 0;
    $offset = 0;
    $len = strlen($str2);
    $result = new(string_ocurrences($str1,$str2));
    while($offset <= strlen($str1))
    {
        $offset = strstr($str1,$offset,$str2);
        if($offset == -1)
        {
            break;
        }
        $result[$count] = $offset;
        $count = $count + 1;
        $offset = $offset + $len;
    }

    ret($result);
}
functions.string_ocurrences_advanced = string_ocurrences_advanced;

fn string_split($string,$separator)
{
    $offset = 0;
    $len = strlen($separator);
    $ocurrences = string_ocurrences_advanced($string,$separator);
    $result = new(get_size($ocurrences)+1);
    clean($result);
    for($i = 0; $i < get_size($result)-1; $i+1)
    {
        $result[$i] = clone(string_sub($string,$offset,$ocurrences[$i]));
        $offset = $ocurrences[$i] + $len;
    }
    $result[get_size($result)-1] = clone(string_sub($string,$offset,strlen($string)));
    remove($ocurrences);
    ret($result);
}
functions.string_split = string_split;

fn string_replace($string,$oldstr,$newstr)
{
    $result = "";
    $offset = 0;
    $len = strlen($oldstr);
    $ocurrences = string_ocurrences_advanced($string,$oldstr);
    for($i = 0; $i < get_size($ocurrences); $i+1)
    {
        $result = string_sub($string,$offset,$ocurrences[$i]);
        $offset = $ocurrences[$i] + $len;
    }
    $result = string_sub($string,$offset,strlen($string));
    remove($ocurrences);
    ret($result);
}
functions.string_replace = string_replace;

fn string_replace_char($string,$oldchar,$newchar)
{
    for($i = 0; $i < strlen($string); $i+1)
    {
        if($string[$i] == $oldchar)
        {
            $string[$i] = $newchar;
        }
        else
        {
            $string[$i] = $string[$i];
        }
    }
    ret($string);
}
functions.string_replace_char = string_replace_char;

//basic constructors
//basic constructors
//basic constructors

fn vector2($x, $y)
{
    $temp = new();
    $temp.x = $x;
    $temp.y = $y;
    ret($temp);
}
functions.vector2 = vector2;

//file functions
//file functions
//file functions

fn read_file($filename)
{
    $size = get_file_size($filename);
    $file = fopen($filename,"rb");
    if($file == 0)
    {
        ret(null);
    }
    $result = "";
    resize($result, $size);
    fread($result,$size,$file);
    fclose($file);
    ret($result);
}
functions.read_file = read_file;

fn write_file($filename,$content)
{
    $file = fopen($filename,"wb");
    fputs($content,$file);
    fclose($file);
    //remove($file);
}
functions.write_file = write_file;

//ini functions
//ini functions
//ini functions

//ini loader without sections
fn ini_load($file)
{
    $result = new();
    $splited = string_split($file,"\n");
    $lsplited = new();
    for($i = 0; $i < get_size($splited); $i+1)
    {
        $lsplited = string_split($splited[$i]," ");
        if(strstr($lsplited[1],"\"") != -1)
        {
            $lsplited[1] = string_replace($lsplited[1],"\"","");
        }
        else
        {
            $lsplited[1] = str_to_num($lsplited[1]);
        }
        set_prop($result,$lsplited[0],$lsplited[1]);
    }
    remove($lsplited);
    remove($splited);
    remove($file);
    ret($result);
}
functions.ini_load = ini_load;

fn ini_save($file,$ini)
{
    $result = "";
    $keys = get_proplist($ini);
    $strnum = "";
    for($i = 0; $i < get_size($keys); $i+1)
    {
        $prop = get_prop($ini,$keys[$i]);
        if($prop[0] > 0)
        {
            sprintf($result,"%s%s \"%s\"\n",$result,$keys[$i],$prop);
        }
        else
        {
            sprintf($result,"%s%s %d\n",$result,$keys[$i],$prop);
        }
    }
    write_file($file,$result);
    remove($result);
    remove($keys);
}
functions.ini_save = ini_save;

// layers functions
// layers functions
// layers functions

fn layer($container)
{
    $temp = new(medium_array, medium_array, INT8);
    if($container > 0)
    {
        remove($temp);
        $temp = $container;
    }
    $alpha = new(get_xsize($temp), get_ysize($temp), INT8)
    clean($alpha,255);
    set_alpha($temp, $alpha);
    ret($temp);
}
functions.layer = layer;

fn layers_merge($layers)// incomplete
{
    $temp_size = new();
    $temp_size.x = get_xsize($layers[0].color);
    $temp_size.y = get_ysize($layers[0].color);

    $result = new($temp_size.x,$temp_size.y,INT8);
    clean($result);
    set_alpha($result,new($temp_size.x,$temp_size.y,INT8));
    clean(get_alpha($result));
    $temp_nsize = get_size($layers[0]);

    remove($temp_size);
    ret($result);
}
functions.layers_merge = layers_merge;

fn layers_render($layers)
{
    clear();
    for($i = 0; $i < get_size($layers); $i+1)
    {
        pixi($layers[$i],$layers[$i].position.x,$layers[$i].position.y);
    }
}
functions.layers_render = layers_render;

// input functions
// input functions
// input functions

fn key_new($keycode,$callback,$arg,$up)//down = 0 for down, 1 for up
{
    $temp = new();
    $temp.keycode = $keycode;
    $temp.callback = $callback;
    $temp.up = $up;
    ret($temp);
}

fn keyboard_new()
{
    $temp = new();
    $temp.keys = new();
    ret($temp);
}
functions.keyboard_new = keyboard_new;

fn keyboard_add($keyboard,$keycode,$up,$callback,$arg)
{
    list_push($keyboard.keys,key_new($keycode,$callback,$arg,$up));
}
functions.keyboard_add = keyboard_add;

fn eventor($system)
{
    while(get_event()) 
    {
        if EVT[ EVT_TYPE ] == EVT_QUIT 
        {
            halt; 
        }
        
        if EVT[EVT_TYPE] == EVT_BUTTONDOWN
        {
            key = EVT[ EVT_KEY ];
            for($i = 0; $i < get_size($system.keyboard.keys); $i+1)
            {
                if($system.keyboard.keys[$i].keycode == key)
                {
                    if($system.keyboard.keys[$i].up == false)
                    {
                        $system.keyboard.keys[$i].callback(default($system.keyboard.keys[$i].arg,null));
                    }
                }
            }
        }
        if EVT[EVT_TYPE] == EVT_BUTTONUP
        {
            key = EVT[ EVT_KEY ];
            for($i = 0; $i < get_size($system.keyboard.keys); $i+1)
            {
                if($system.keyboard.keys[$i].keycode == key)
                {
                    if($system.keyboard.keys[$i].up == true)
                    {
                        $system.keyboard.keys[$i].callback(default($system.keyboard.keys[$i].arg,null));
                    }
                }
            }
        }

        if EVT[ EVT_KEY ] == KEY_MOUSE_LEFT
        {
            x = EVT[ EVT_X ]
            y = EVT[ EVT_Y ]
            tnum = 0
            if EVT[ EVT_KEY ] == EVT_MOUSEBUTTONDOWN 
            {
            }
            if EVT[ EVT_KEY ] == EVT_MOUSEMOVE 
            {
            }
            if EVT[ EVT_KEY ] == EVT_MOUSEBUTTONUP
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHBEGIN
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHMOVE
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHEND
            {
            }
        }
    }
}
functions.eventor = eventor;

//startup functions
//startup functions
//startup functions

fn system_loop($system, $callback, $arg)
{
    while(true)
    {
        layers_render($system.layers);
        print_fps_screen();
        eventor($system);
        frame();
    }
}
functions.system_loop = system_loop;

fn manual_loop($system)
{
    layers_render($system.layers);
    eventor($system);
    frame();
}
functions.manual_loop = manual_loop;

fn system_new($configpath)
{
    $configpath = default($configpath,"data/config.ini");
    $system = new();
    $system.config = ini_load(read_file($configpath));
    $system.layers = new();
    list_push($system.layers,layer(0,0,WINDOW_XSIZE,WINDOW_YSIZE));
    if($system.config < 0)
    {
        logf("Error loading config file: %s\n", $configpath);
        halt;
    }
    else
    {
        $system.config.width = default($system.config.width,WINDOW_XSIZE);
        $system.config.height = default($system.config.height,WINDOW_YSIZE);
        resize( get_screen(), $system.config.width, $system.config.height );
        set_pixel_size( WINDOW_XSIZE / $system.config.width );
    }
    $system.window = new();
    $system.keyboard = keyboard_new();
    start_timer(0);
    refresh_seed();//required to get a different random number each time  
    ret($system);
}
functions.system_new = system_new;

//bytestring functions
//bytestring functions
//bytestring functions

fn bytestring_to_num($str)
{
    $result = 0;
    $len = get_size($str);
    if($len > 1)
    {    
        for($i=0;$i<$len-1;$i+1)
        {
            $result = pow(256,($len-$i-1))*$str[$i] + $result;
        }
    }
    $result = $result + $str[$len-1] - ($len-1);
    ret($result);
}

fn num_to_bytestring($num)
{
    $result = ""
    sprintf($result, "");
    $len = 1;
    $max = 256;
    while($num >= $max)
    {
        $len = $len + 1;
        $max = $max * 256;
    }
    $max = $max / 256;
    for($i=0;$i<$len-1;$i+1)
    {
        sprintf($result, "%s%c", $result, $num / $max);
        $num = $num % $max;
        $max = $max / 256;
    }
    sprintf($result, "%s%c", $result, $num + ($len-1));
    ret($result);
}

//main functions
//main functions
//main functions


fn run_function($func,$args)
{
    ret(get_prop(functions,$func)($args[0],$args[1],$args[2],$args[3],$args[4],$args[5],$args[6],$args[7],$args[8],$args[9],$args[10],$args[11],$args[12],$args[13],$args[14],$args[15],$args[16],$args[17],$args[18],$args[19],$args[20],$args[21],$args[22],$args[23],$args[24],$args[25],$args[26],$args[27],$args[28],$args[29],$args[30],$args[31],$args[32],$args[33],$args[34],$args[35],$args[36],$args[37],$args[38],$args[39],$args[40],$args[41],$args[42],$args[43],$args[44],$args[45],$args[46],$args[47],$args[48],$args[49],$args[50],$args[51],$args[52],$args[53],$args[54],$args[55],$args[56],$args[57],$args[58],$args[59],$args[60],$args[61],$args[62],$args[63],$args[64],$args[65],$args[66],$args[67],$args[68],$args[69],$args[70],$args[71],$args[72],$args[73],$args[74],$args[75],$args[76],$args[77],$args[78],$args[79],$args[80],$args[81],$args[82],$args[83],$args[84],$args[85],$args[86],$args[87],$args[88],$args[89],$args[90],$args[91],$args[92],$args[93],$args[94],$args[95],$args[96],$args[97],$args[98],$args[99]));
}

fn treat_args($splited, $size)
{
    $args = new($size-1);
    for ($i = 1; $i < $size; $i+1)
    {
        if($splited[$i][0] == '#')
        {
            $temp = string_sub($splited[$i], 1, get_size($splited[$i]));
            $args[$i-1] = recursive_prop(constants, $temp);
        }
        else
        {
            if($splited[$i][0] == '$')
            {
                $temp = string_sub($splited[$i], 1, get_size($splited[$i]));
                $args[$i-1] = recursive_prop(variables, $temp);
            }
            else
            {
                if($splited[$i][0] == '@')
                {
                    $temp = string_sub($splited[$i], 1, get_size($splited[$i]));
                    $args[$i-1] = recursive_prop(functions, $temp);
                }
                else
                {
                    if(($splited[$i][0] > 47 && $splited[$i][0] < 58) || $splited[$i][0] == '-')
                    {
                        $args[$i-1] = str_to_num($splited[$i]);
                    }
                    else
                    {
                        $args[$i-1] = $splited[$i];
                    }
                }
            }
        }
    }
    ret($args);
}

fn interpret($command)
{
    $splited = string_split($command, " ");
    $size = get_size($splited);
    $args = treat_args($splited,$size);
    if(strstr($splited[0], 1, ":", 0) > 0)
    {
        $cloned = clone($splited[0]);
        $localsplited = string_split($cloned, ":");
        recursive_set_prop(variables, $localsplited[1], run_function($localsplited[0], $args));
        remove($cloned);
        for ($i = 0; $i < get_size($localsplited); $i+1)
        {
            remove($localsplited[$i]);
        }
        remove($localsplited);
    }
    else
    {
        run_function($splited[0], $args);
    }
    
    for ($i = 0; $i < $size; $i+1)
    {
        remove($splited[$i]);
    }
    remove($splited);
    remove($args);
}