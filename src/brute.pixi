//constants
//constants
//constants

null = 0;
false = 0;
true = 1;
medium_array = 64;

//keycodes
//keycodes
//keycodes

KEY_NULL = 0;
KEY_SOH = 1;
KEY_STX = 2;
KEY_ETX = 3;
KEY_EOT = 4;
KEY_ENQ = 5;
KEY_ACK = 6;
KEY_BEL = 7;
KEY_BS = 8;
KEY_HT = 9;
KEY_LF = 10;
KEY_VT = 11;
KEY_FF = 12;
KEY_CR = 13;
KEY_SO = 14;
KEY_SI = 15;
KEY_DLE = 16;
KEY_DC1 = 17;
KEY_DC2 = 18;
KEY_DC3 = 19;
KEY_DC4 = 20;
KEY_NAK = 21;
KEY_SYN = 22;
KEY_ETB = 23;
KEY_CAN = 24;
KEY_EM = 25;
KEY_SUB = 26;
KEY_ESC = 27;
KEY_FS = 28;
KEY_GS = 29;
KEY_RS = 30;
KEY_US = 31;
//KEY_SPACE = 32;
KEY_EXCLAMATION_MARK = 33;
KEY_QUOTATION_MARK = 34;
KEY_HASH = 35;
KEY_DOLLAR = 36;
KEY_PERCENT = 37;
KEY_AMPERSAND = 38;
KEY_APOSTROPHE = 39;
KEY_LEFT_PARENTHESIS = 40;
KEY_RIGHT_PARENTHESIS = 41;
KEY_ASTERISK = 42;
KEY_PLUS = 43;
KEY_COMMA = 44;
KEY_MINUS = 45;
KEY_PERIOD = 46;
KEY_SLASH = 47;
KEY_0 = 48;
KEY_1 = 49;
KEY_2 = 50;
KEY_3 = 51;
KEY_4 = 52;
KEY_5 = 53;
KEY_6 = 54;
KEY_7 = 55;
KEY_8 = 56;
KEY_9 = 57;
KEY_COLON = 58;
KEY_SEMICOLON = 59;
KEY_LESS_THAN = 60;
KEY_EQUALS = 61;
KEY_GREATER_THAN = 62;
KEY_QUESTION_MARK = 63;
KEY_AT = 64;
KEY_A = 65;
KEY_B = 66;
KEY_C = 67;
KEY_D = 68;
KEY_E = 69;
KEY_F = 70;
KEY_G = 71;
KEY_H = 72;
KEY_I = 73;
KEY_J = 74;
KEY_K = 75;
KEY_L = 76;
KEY_M = 77;
KEY_N = 78;
KEY_O = 79;
KEY_P = 80;
KEY_Q = 81;
KEY_R = 82;
KEY_S = 83;
KEY_T = 84;
KEY_U = 85;
KEY_V = 86;
KEY_W = 87;
KEY_X = 88;
KEY_Y = 89;
KEY_Z = 90;
KEY_LEFT_BRACKET = 91;
KEY_BACKSLASH = 92;
KEY_RIGHT_BRACKET = 93;
KEY_CARET = 94;
KEY_UNDERSCORE = 95;
KEY_GRAVE_ACCENT = 96;
KEY_a = 97;
KEY_b = 98;
KEY_c = 99;
KEY_d = 100;
KEY_e = 101;
KEY_f = 102;
KEY_g = 103;
KEY_h = 104;
KEY_i = 105;
KEY_j = 106;
KEY_k = 107;
KEY_l = 108;
KEY_m = 109;
KEY_n = 110;
KEY_o = 111;
KEY_p = 112;
KEY_q = 113;
KEY_r = 114;
KEY_s = 115;
KEY_t = 116;
KEY_u = 117;
KEY_v = 118;
KEY_w = 119;
KEY_x = 120;
KEY_y = 121;
KEY_z = 122;
KEY_LEFT_BRACE = 123;
KEY_PIPE = 124;
KEY_RIGHT_BRACE = 125;
KEY_TILDE = 126;
//KEY_DELETE = 127;

//primitive functions
//primitive functions
//primitive functions

fn dummy()
{
    ret(0);
}

//memory functions
//memory functions
//memory functions

//container counter
container_counter = 0;

fn container_count()
{
    $count = new();
    ret($count);
}

fn print_container_count()
{
    container_counter = container_count();
    printf("Container count: %d\n", container_counter);
    remove(container_counter);
}

fn flex($object,$size)
{
    $newsize = get_size($object) + $size;
    resize($object,$newsize);
    ret($newsize);
}


//util functions
//util functions
//util functions

fn refresh_seed()
{
    rand_seed( get_timer() + get_ticks() );
}

fn random($min,$max)
{
    //considering that rand() returns a value between 0 and 32767
    ret((rand() % ($max - $min + 1)) + $min);
}

fn default($obj, $default)
{
    if($obj == null)
    {
        ret($default);
    }
    else
    {
        ret($obj);
    }
}

//list functions
//list functions
//list functions

fn list_push($list,$element)
{
    $list[flex($list, 1)-1] = $element;
}

fn list_pop($list)
{
    flex($list, -1);
}

fn list_insert($list,$element,$position)
{
    $oldsize = flex($list, 1) - 1;
    $position = default($position,$oldsize);
    for($i = $oldsize; $i >= $position; $i-1)
    {
        $list[$i+1] = $list[$i];
    }
    $list[$position] = $element;
    remove($oldsize);
    //remove($position);
}

fn list_remove($list,$position)
{
    $oldsize = get_size($list);
    for($i = $position; $i < $oldsize; $i+1)
    {
        $list[$i] = $list[$i+1];
    }
    resize($list,$oldsize - 1);
    remove($oldsize);
    //remove($position);
}

fn list_find($list,$element)
{
    $oldsize = get_size($list);
    for($i = 0; $i < $oldsize; $i+1)
    {
        if($list[$i] == $element)
        {
            ret($i);
        }
    }
    remove($oldsize);
    ret(-1);
}

//strings functions
//strings functions
//strings functions

fn string_new($size)
{
    $temp = "";
    $temp = new($size);
    ret($temp);
}

fn string_sub($string,$start,$end)
{
    $newstr = "";
    resize($newstr,$end - $start);
    $offset = 0;
    for($i = $start; $i < $end; $i+1)
    {
        $newstr[$offset] = $string[$i];
        $offset = $offset + 1;
    }
    ret($newstr);
}

//counting ocurrences using strstr
fn string_ocurrences($str1,$str2)
{
    $count = 0;
    $offset = 0;
    $len = strlen($str2);
    while($offset <= strlen($str1))
    {
        $offset = strstr($str1,$offset,$str2);
		if($offset == -1)
        {
            break;
        }
		$count = $count + 1;
        $offset = $offset + $len;
	}
    //remove($offset);
    ret($count);
}

//this string returns the positions of each ocurrence
fn string_ocurrences_advanced($str1,$str2)
{
    $count = 0;
    $offset = 0;
    $len = strlen($str2);
    $result = new(string_ocurrences($str1,$str2));
    while($offset <= strlen($str1))
    {
        $offset = strstr($str1,$offset,$str2);
        if($offset == -1)
        {
            break;
        }
        $result[$count] = $offset;
        $count = $count + 1;
        $offset = $offset + $len;
    }

    ret($result);
}

fn string_split($string,$separator)
{
    $offset = 0;
    $len = strlen($separator);
    $ocurrences = string_ocurrences_advanced($string,$separator);
    $result = new(get_size($ocurrences)+1);
    clean($result);
    for($i = 0; $i < get_size($result)-1; $i+1)
    {
        $temp = string_sub($string,$offset,$ocurrences[$i])
        $result[$i] = clone($temp);
        $offset = $ocurrences[$i] + $len;
    }
    $temp = string_sub($string,$offset,strlen($string));
    $result[get_size($result)-1] = clone($temp);
    remove($ocurrences);
    ret($result);
}

fn string_replace($string,$oldstr,$newstr)
{
    $result = "";
    $offset = 0;
    $len = strlen($oldstr);
    $ocurrences = string_ocurrences_advanced($string,$oldstr);
    for($i = 0; $i < get_size($ocurrences); $i+1)
    {
        $result = string_sub($string,$offset,$ocurrences[$i]);
        $offset = $ocurrences[$i] + $len;
    }
    $result = string_sub($string,$offset,strlen($string));
    remove($ocurrences);
    ret($result);
}

fn string_replace_char($string,$oldchar,$newchar)
{
    for($i = 0; $i < strlen($string); $i+1)
    {
        if($string[$i] == $oldchar)
        {
            $string[$i] = $newchar;
        }
        else
        {
            $string[$i] = $string[$i];
        }
    }
    ret($string);
}

//basic constructors
//basic constructors
//basic constructors

fn vector2($x, $y)
{
    $temp = new();
    $temp.x = $x;
    $temp.y = $y;
    ret($temp);
}

//file functions
//file functions
//file functions

fn read_file($filename)
{
    $size = get_file_size($filename);
    $file = fopen($filename,"rb");
    if($file == null)
    {
        ret(null);
    }
    $result = "";
    resize($result, $size);
    fread($result,$size,$file);
    fclose($file);
    ret($result);
}

fn write_file($filename,$content)
{
    $file = fopen($filename,"wb");
    fputs($content,$file);
    fclose($file);
    //remove($file);
}

//ini functions
//ini functions
//ini functions

//ini loader without sections
fn ini_load($file)
{
    $result = new();
    $splited = string_split($file,"\n");
    $lsplited = new();
    for($i = 0; $i < get_size($splited); $i+1)
    {
        $lsplited = string_split($splited[$i]," ");
        if(strstr($lsplited[1],"\"") != -1)
        {
            $lsplited[1] = string_replace($lsplited[1],"\"","");
        }
        else
        {
            $lsplited[1] = str_to_num($lsplited[1]);
        }
        set_prop($result,$lsplited[0],$lsplited[1]);
    }
    remove($lsplited);
    remove($splited);
    remove($file);
    ret($result);
}

fn ini_save($file,$ini)
{
    $result = "";
    $keys = get_proplist($ini);
    $strnum = "";
    for($i = 0; $i < get_size($keys); $i+1)
    {
        $prop = get_prop($ini,$keys[$i]);
        if($prop[0] > 0)
        {
            sprintf($result,"%s%s \"%s\"\n",$result,$keys[$i],$prop);
        }
        else
        {
            sprintf($result,"%s%s %d\n",$result,$keys[$i],$prop);
        }
    }
    write_file($file,$result);
    remove($result);
    remove($keys);
}

// layers functions
// layers functions
// layers functions

fn layer($x,$y,$width,$height)
{
    $temp = new($width, $height, INT8);
    set_alpha($temp, new($width, $height, INT8));
    $temp.position = vector2($x,$y);
    ret($temp);
}

fn layers_render($layers)
{
    $temp_size = new();
    $temp_size.x = get_xsize($layers[0].color);
    $temp_size.y = get_ysize($layers[0].color);

    $result = new($temp_size.x,$temp_size.y,INT8);
    clear($result);
    set_alpha($result,new($temp_size.x,$temp_size.y,INT8));
    clear(get_alpha($result));
    $temp_nsize = get_size($layers[0]);

    for($i = 0; $i < get_size($layers); $i+1)
    {
        for($j = 0; $j < $temp_nsize; $j+1)
        {
            pixi($result,$result.position.x,$result.position.y);
        }
    }

    remove($temp_size);
    ret($result);
}

// input functions
// input functions
// input functions

fn key_new($keycode,$callback,$arg,$down)//down = 1 for down, 0 for up
{
    $temp = new();
    $temp.keycode = $keycode;
    $temp.callback = $callback;
    $temp.down = $down;
    ret($temp);
}

fn keyboard_new()
{
    $temp = new();
    $temp.keys = new();
    ret($temp);
}

fn keyboard_add($keyboard,$keycode,$down,$callback,$arg)
{
    list_push($keyboard.keys,key_new($keycode,$callback,$arg,$down));
}

fn eventor($system)
{
    while(get_event()) 
    {
        if EVT[ EVT_TYPE ] == EVT_QUIT 
        {
            halt; 
        }
        
        if EVT[EVT_TYPE] == EVT_BUTTONDOWN
        {
            key = EVT[ EVT_KEY ];
            for($i = 0; $i < get_size($system.keyboard.keys); $i+1)
            {
                if($system.keyboard.keys[$i].keycode == key)
                {
                    if($system.keyboard.keys[$i].down == true)
                    {
                        $system.keyboard.keys[$i].callback(default($system.keyboard.keys[$i].arg,null));
                    }
                }
            }
        }
        if EVT[EVT_TYPE] == EVT_BUTTONUP
        {
            key = EVT[ EVT_KEY ];
            for($i = 0; $i < get_size($system.keyboard.keys); $i+1)
            {
                if($system.keyboard.keys[$i].keycode == key)
                {
                    if($system.keyboard.keys[$i].down == false)
                    {
                        $system.keyboard.keys[$i].callback(default($system.keyboard.keys[$i].arg,null));
                    }
                }
            }
        }

        if EVT[ EVT_KEY ] == KEY_MOUSE_LEFT
        {
            x = EVT[ EVT_X ]
            y = EVT[ EVT_Y ]
            tnum = 0
            if EVT[ EVT_KEY ] == EVT_MOUSEBUTTONDOWN 
            {
            }
            if EVT[ EVT_KEY ] == EVT_MOUSEMOVE 
            {
            }
            if EVT[ EVT_KEY ] == EVT_MOUSEBUTTONUP
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHBEGIN
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHMOVE
            {
            }
            if EVT[ EVT_KEY ] == EVT_TOUCHEND
            {
            }
        }
        
    }
}

//startup functions
//startup functions
//startup functions

fn system_loop($system, $callback, $arg)
{
    while(true)
    {
        eventor($system);
        $callback(default($arg,null));
        frame();
    }
}

fn system_new($configpath)
{
    $configpath = default($configpath,"data/config.ini");
    $system = new();
    $system.config = ini_load(read_file($configpath));
    $system.layers = new();
    list_push($system.layers,layer(0,0,WINDOW_XSIZE,WINDOW_YSIZE));
    if($system.config == null)
    {
        printf("Error loading config file: %s\n", $configpath);
        halt;
    }
    else
    {
        $system.config.width = default($system.config.width,WINDOW_XSIZE);
        $system.config.height = default($system.config.height,WINDOW_YSIZE);
        resize( get_screen(), $system.config.width, $system.config.height );
        set_pixel_size( WINDOW_XSIZE / $system.config.width );
    }
    $system.window = new();
    $system.keyboard = keyboard_new();
    start_timer(0);
    refresh_seed();//required to get a different random number each time  
    ret($system);
}